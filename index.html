<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ProGlove Scanner - Complete System</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: Arial, sans-serif; background: #1a1a1a; color: white; padding: 10px; }
        .container { max-width: 100%; margin: 0 auto; display: flex; flex-direction: column; gap: 15px; }
        .header { background: #4285f4; padding: 15px; text-align: center; border-radius: 10px; }
        .card { background: #2a2a2a; padding: 15px; border-radius: 10px; margin-bottom: 10px; }
        .sync-section { background: #333; padding: 15px; border-radius: 8px; margin-bottom: 15px; }
        .sync-controls { display: flex; gap: 10px; margin-bottom: 10px; }
        .sync-btn { flex: 1; padding: 12px; border: none; border-radius: 6px; font-size: 14px; font-weight: bold; cursor: pointer; }
        .download-btn { background: #4285f4; color: white; }
        .upload-btn { background: #34a853; color: white; }
        .export-btn { background: #f57c00; color: white; }
        .emergency-btn { background: #ea4335; color: white; }
        .sync-btn:disabled { background: #666; cursor: not-allowed; }
        .system-status { padding: 10px; margin-top: 10px; border-radius: 5px; text-align: center; font-size: 12px; background: #444; border-left: 4px solid #f57c00; }
        .sync-status { padding: 10px; margin-top: 10px; border-radius: 5px; text-align: center; font-size: 12px; background: #444; border-left: 4px solid #4285f4; }
        .sync-status.success { border-left-color: #34a853; background: #2a2a2a; }
        .sync-status.error { border-left-color: #ea4335; background: #2a2a2a; }
        .mode-buttons { display: flex; gap: 10px; margin-bottom: 15px; }
        .mode-btn { flex: 1; padding: 15px; border: none; border-radius: 8px; font-size: 16px; font-weight: bold; cursor: pointer; }
        .kitchen-btn { background: #34a853; color: white; }
        .return-btn { background: #ea4335; color: white; }
        .mode-btn.active { box-shadow: 0 0 0 3px white; }
        .dropdown { width: 100%; padding: 12px; background: #444; color: white; border: 2px solid #666; border-radius: 6px; font-size: 16px; margin-top: 10px; }
        .scan-controls { display: flex; gap: 10px; margin-bottom: 15px; }
        .scan-btn { flex: 1; padding: 15px; border: none; border-radius: 8px; font-size: 16px; font-weight: bold; cursor: pointer; }
        .start-btn { background: #34a853; color: white; }
        .stop-btn { background: #ea4335; color: white; }
        .scan-btn:disabled { background: #666; cursor: not-allowed; }
        .proglove-input { width: 100%; padding: 15px; font-size: 18px; background: #333; color: white; border: 2px solid #666; border-radius: 8px; margin-bottom: 15px; text-align: center; }
        .proglove-input.error { border-color: #ea4335; animation: shake 0.5s; }
        .scanning-active { animation: pulse 1.5s infinite; border: 3px solid #34a853; }
        .feedback { padding: 12px; margin-top: 10px; border-radius: 6px; text-align: center; font-weight: bold; min-height: 50px; display: flex; align-items: center; justify-content: center; }
        .success { background: #34a853; }
        .error { background: #ea4335; }
        .warning { background: #f57c00; }
        .info { background: #4285f4; }
        .hidden { display: none; }
        .stats-grid { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; margin-bottom: 15px; }
        .stat-item { background: #333; padding: 15px; border-radius: 8px; text-align: center; }
        .stat-value { font-size: 24px; font-weight: bold; }
        .kitchen-stat { color: #34a853; }
        .return-stat { color: #ea4335; }
        .active-stat { color: #4285f4; }
        .prep-stat { color: #f57c00; }
        .response-time { font-size: 12px; color: #888; text-align: center; margin-top: 5px; }
        .local-data { background: #2a2a2a; padding: 10px; border-radius: 5px; margin-top: 10px; font-size: 12px; border-left: 4px solid #f57c00; }
        .upload-info { background: #2a2a2a; padding: 10px; border-radius: 5px; margin-top: 10px; font-size: 12px; border-left: 4px solid #4285f4; }
        .cross-team-data { background: #2a2a2a; padding: 10px; border-radius: 5px; margin-top: 10px; font-size: 12px; border-left: 4px solid #f57c00; }
        .data-row { display: flex; justify-content: space-between; margin-bottom: 5px; }
        .data-label { font-weight: bold; }
        .admin-section { border: 2px solid #f57c00; }
        .backup-status { background: #2a2a2a; padding: 8px; border-radius: 5px; margin-top: 5px; font-size: 11px; border-left: 4px solid #34a853; }
        
        /* Dish Statistics Table Styles */
        .dish-stats-table { 
            width: 100%; 
            border-collapse: collapse; 
            margin-top: 10px;
            font-size: 12px;
        }
        .dish-stats-table th {
            background: #4285f4;
            color: white;
            padding: 8px;
            text-align: center;
            border: 1px solid #555;
        }
        .dish-stats-table td {
            padding: 8px;
            text-align: center;
            border: 1px solid #555;
            background: #333;
        }
        .dish-stats-table .dish-header {
            background: #34a853;
            font-weight: bold;
        }
        .dish-stats-table .total-row {
            background: #f57c00;
            font-weight: bold;
        }
        .dish-stats-table .expected-highlight {
            background: #ffeb3b;
            color: #000;
            font-weight: bold;
        }
        .dish-stats-table .missing {
            background: #ff4444;
            color: white;
            font-weight: bold;
        }
        .dish-stats-table .extra {
            background: #ff9800;
            color: white;
            font-weight: bold;
        }

        /* User Assignment Table Styles */
        .user-assignment-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
            font-size: 11px;
        }
        .user-assignment-table th {
            background: #34a853;
            color: white;
            padding: 6px;
            text-align: center;
            border: 1px solid #555;
        }
        .user-assignment-table td {
            padding: 6px;
            text-align: center;
            border: 1px solid #555;
            background: #333;
        }
        .user-assignment-table .user-cell {
            max-width: 80px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        @keyframes pulse { 0% { box-shadow: 0 0 0 0 rgba(52, 168, 83, 0.7); } 70% { box-shadow: 0 0 0 15px rgba(52, 168, 83, 0); } 100% { box-shadow: 0 0 0 0 rgba(52, 168, 83, 0); } }
        @keyframes shake { 0%, 100% { transform: translateX(0); } 25% { transform: translateX(-5px); } 75% { transform: translateX(5px); } }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üß§ ProGlove Scanner - Complete System</h1>
            <p>Multi-Device ‚Ä¢ Real-Time Sync ‚Ä¢ Manager Dashboard</p>
        </div>
        
        <div class="card">
            <h3>üìä SYSTEM STATUS</h3>
            <div class="system-status" id="systemStatus">
                üîÑ Connecting to cloud...
            </div>
            <div class="backup-status" id="backupStatus">
                üíæ Hybrid backup initializing...
            </div>
            <div class="local-data" id="syncInfo">
                <strong>Sync Status:</strong> Checking multi-device connection...
            </div>
        </div>

        <div class="card">
            <h3>üì± SELECT MODE</h3>
            <div class="mode-buttons">
                <button class="mode-btn kitchen-btn" onclick="setMode('kitchen')" id="kitchenBtn">üç≥ KITCHEN</button>
                <button class="mode-btn return-btn" onclick="setMode('return')" id="returnBtn">üîÑ RETURN</button>
            </div>
        </div>
        
        <div class="card">
            <h3>üë§ SELECT USER</h3>
            <select class="dropdown" id="userDropdown" onchange="selectUser()">
                <option value="">-- Select User --</option>
            </select>
        </div>
        
        <div class="card hidden" id="dishSection">
            <h3>üìù SELECT DISH LETTER</h3>
            <select class="dropdown" id="dishDropdown" onchange="selectDishLetter()">
                <option value="">-- Select Dish Letter --</option>
            </select>
        </div>
        
        <div class="card hidden" id="crossTeamDataSection">
            <h3>üìä LIVE BOWL STATUS</h3>
            <div class="cross-team-data" id="crossTeamData">
                No active bowls yet
            </div>
        </div>
        
        <div class="card" id="scanSection">
            <h3>üîç SCANNING</h3>
            <div class="scan-controls">
                <button class="scan-btn start-btn" id="startBtn" onclick="startScanning()">‚ñ∂ START SCANNING</button>
                <button class="scan-btn stop-btn" id="stopBtn" onclick="stopScanning()" disabled>‚èπ STOP & BACKUP</button>
            </div>
            
            <input type="text" class="proglove-input" id="progloveInput" placeholder="Click START SCANNING to begin..." disabled>
            
            <div class="response-time">
                Response time: <span id="responseTimeValue">0</span>ms
            </div>
            
            <div class="stats-grid">
                <div class="stat-item">
                    <div class="stat-label">Active Bowls</div>
                    <div class="stat-value active-stat" id="activeCount">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label" id="prepLabel">Prepared Today</div>
                    <div class="stat-value prep-stat" id="prepCount">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">My Scans Today</div>
                    <div class="stat-value kitchen-stat" id="myScansCount">0</div>
                </div>
            </div>
            
            <div class="feedback info" id="feedback">
                ‚úÖ System ready - Select mode and user to start
            </div>
        </div>

        <!-- USER ASSIGNMENT DISPLAY -->
        <div class="card">
            <h3>üë®‚Äçüç≥ DISH PREPARATION ASSIGNMENTS</h3>
            <div style="background: #444; padding: 10px; border-radius: 5px; margin-bottom: 10px;">
                <small>‚ÑπÔ∏è Manager View - Who prepared each dish letter today</small>
            </div>
            <div id="userAssignment">
                <table class="user-assignment-table">
                    <thead>
                        <tr>
                            <th>Dish</th>
                            <th>Prepared By</th>
                            <th>Count</th>
                            <th>Dish</th>
                            <th>Prepared By</th>
                            <th>Count</th>
                            <th>Dish</th>
                            <th>Prepared By</th>
                            <th>Count</th>
                        </tr>
                    </thead>
                    <tbody id="userAssignmentBody">
                        <!-- User assignments will be populated here -->
                    </tbody>
                </table>
            </div>
            <div class="local-data" style="margin-top: 10px;">
                <strong>Last Updated:</strong> <span id="assignmentUpdateTime">Never</span>
            </div>
        </div>

        <!-- DISH SCANNING STATISTICS TABLE -->
        <div class="card">
            <h3>üìà DISH SCANNING STATISTICS</h3>
            <div style="background: #444; padding: 10px; border-radius: 5px; margin-bottom: 10px;">
                <small>‚ÑπÔ∏è Real-time tracking of scanned dishes - verify counts for accuracy</small>
            </div>
            <div id="dishStatistics">
                <table class="dish-stats-table">
                    <thead>
                        <tr>
                            <th>Dish</th>
                            <th>Scanned</th>
                            <th>Expected</th>
                            <th>Difference</th>
                            <th>Status</th>
                        </tr>
                    </thead>
                    <tbody id="dishStatsBody">
                        <!-- Statistics will be populated here -->
                    </tbody>
                </table>
            </div>
            <div class="local-data" style="margin-top: 10px;">
                <strong>Last Updated:</strong> <span id="statsUpdateTime">Never</span>
            </div>
        </div>

        <!-- HYBRID BACKUP SECTION -->
        <div class="card admin-section">
            <h3>üíæ HYBRID BACKUP SYSTEM</h3>
            <div style="background: #444; padding: 10px; border-radius: 5px; margin-bottom: 10px;">
                <small>‚ÑπÔ∏è Instant sync + Smart backup ‚Ä¢ Never runs during scanning</small>
            </div>
            
            <div class="sync-controls">
                <button class="sync-btn emergency-btn" onclick="forceSmartBackup()" id="smartBackupBtn">
                    üî• SMART BACKUP NOW
                </button>
                <button class="sync-btn download-btn" onclick="forceAllDevicesSync()" id="forceSyncBtn">
                    üîÑ FORCE SYNC ALL DEVICES
                </button>
                <button class="sync-btn download-btn" onclick="loadFromFirebase()" id="loadBackupBtn">
                    üì• LOAD FROM BACKUP
                </button>
            </div>
            <div class="local-data" id="backupInfo">
                <strong>Backup Status:</strong> Last backup: Never
            </div>
        </div>

        <!-- ADMIN JSON IMPORT SECTION -->
        <div class="card admin-section">
            <h3>üîß ADMIN: IMPORT ORDER DATA</h3>
            <div style="background: #444; padding: 10px; border-radius: 5px; margin-bottom: 10px;">
                <small>‚ÑπÔ∏è For admin use only - imports company/customer data to bowls</small>
            </div>
            
            <textarea id="jsonInput" placeholder="Paste JSON order data from Bella Bona website here..." 
                      style="width:100%; height:120px; background:#333; color:white; padding:10px; border-radius:5px; border:1px solid #666; font-size: 12px;"></textarea>
            
            <div style="display:flex; gap:10px; margin-top:10px;">
                <button onclick="processBellaBonaJSON()" class="sync-btn upload-btn" style="flex:1;">
                    üì• IMPORT & ASSIGN DATA
                </button>
                <button onclick="clearJSONInput()" class="sync-btn export-btn" style="flex:1;">
                    üóëÔ∏è CLEAR
                </button>
            </div>
            <div id="importResult" style="margin-top:10px; font-size:12px;"></div>
        </div>

        <!-- EXCEL EXPORT SECTION -->
        <div class="card">
            <h3>üìä EXCEL EXPORT</h3>
            <div class="sync-section">
                <div class="sync-controls">
                    <button class="sync-btn export-btn" onclick="exportToExcel()" id="exportBtn">
                        üì§ EXPORT TO EXCEL
                    </button>
                </div>
                <div class="sync-status" id="syncStatus">
                    ‚úÖ Excel export ready
                </div>
                <div class="local-data" id="localDataInfo">
                    <strong>Current Data:</strong> Loading...
                </div>
                <div class="upload-info" id="uploadInfo">
                    <strong>Last Sync:</strong> Never
                </div>
            </div>
        </div>
    </div>

    <!-- Firebase Configuration -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/12.4.0/firebase-app.js";
        import { getDatabase, ref, set, onValue, get } from "https://www.gstatic.com/firebasejs/12.4.0/firebase-database.js";

        const firebaseConfig = {
            apiKey: "AIzaSyCL3hffCHosBceIRGR1it2dYEDb3uxIrJw",
            authDomain: "proglove-scanner.firebaseapp.com",
            databaseURL: "https://proglove-scanner-default-rtdb.europe-west1.firebasedatabase.app",
            projectId: "proglove-scanner",
            storageBucket: "proglove-scanner.firebasestorage.app",
            messagingSenderId: "177575768177",
            appId: "1:177575768177:web:0a0acbf222218e0c0b2bd0"
        };

        let app;
        let database;
        let lastBackupTime = null;
        let isSyncing = false;
        let lastFirebaseUpdate = null;

        // HYBRID BACKUP SYSTEM
        class SmartBackupSystem {
            constructor() {
                this.lastIncrementalBackup = 0;
                this.lastFullBackup = 0;
                this.pendingScans = [];
                this.isBackupRunning = false;
                this.backupTimer = null;
            }

            async syncScanInstantly(scanData) {
                if (!database) {
                    this.queueScanForBackup(scanData);
                    return;
                }
                
                try {
                    await this.syncSingleScan(scanData);
                    console.log('‚úÖ Instant scan sync completed');
                } catch (error) {
                    console.log('Instant sync failed, queuing for backup:', error);
                    this.queueScanForBackup(scanData);
                }
            }

            async syncSingleScan(scanData) {
                const appDataRef = ref(database, 'appData');
                const snapshot = await get(appDataRef);
                const currentData = snapshot.val() || {};
                
                // Get current data
                const currentActiveBowls = currentData.activeBowls || [];
                const currentPreparedBowls = currentData.preparedBowls || [];
                const currentMyScans = currentData.myScans || [];
                const currentScanHistory = currentData.scanHistory || [];
                
                // Check if scan already exists in Firebase (prevent duplicates)
                const scanExists = currentMyScans.some(scan => 
                    scan.code === scanData.code && scan.timestamp === scanData.timestamp
                );
                
                if (!scanExists) {
                    const updatedData = {
                        ...currentData,
                        activeBowls: mergeBowls(currentActiveBowls, window.appData.activeBowls),
                        preparedBowls: mergeBowls(currentPreparedBowls, window.appData.preparedBowls),
                        myScans: [...currentMyScans, scanData],
                        scanHistory: [{
                            type: scanData.type,
                            code: scanData.code,
                            user: scanData.user,
                            timestamp: new Date().toISOString(),
                            message: `${scanData.dish} ${scanData.type}: ${scanData.code}`
                        }, ...currentScanHistory],
                        lastSync: new Date().toISOString(),
                        lastUpdatedBy: window.appData.user || 'Unknown',
                        lastUpdatedTime: new Date().toISOString()
                    };

                    await set(appDataRef, updatedData);
                    console.log('‚úÖ Instant sync: Scan saved to Firebase');
                }
            }

            mergeArrays(arr1, arr2) {
                const merged = [...arr1];
                const existingKeys = new Set(arr1.map(item => item.code + item.timestamp));
                
                arr2.forEach(item => {
                    const key = item.code + item.timestamp;
                    if (!existingKeys.has(key)) {
                        merged.push(item);
                    }
                });
                
                return merged;
            }

            queueScanForBackup(scanData) {
                this.pendingScans.push({
                    ...scanData,
                    queueTime: Date.now()
                });
                console.log('üì¶ Scan queued for backup. Queue size:', this.pendingScans.length);
                this.updateBackupStatus();
            }

            async runIncrementalBackup() {
                if (this.isBackupRunning || this.pendingScans.length === 0 || window.appData.scanning) {
                    return;
                }
                
                this.isBackupRunning = true;
                const scansToBackup = [...this.pendingScans];
                this.pendingScans = [];

                try {
                    if (!database) throw new Error('Firebase not available');
                    
                    const backupRef = ref(database, `incrementalBackups/${Date.now()}`);
                    await set(backupRef, {
                        scans: scansToBackup,
                        count: scansToBackup.length,
                        timestamp: new Date().toISOString(),
                        type: 'incremental'
                    });

                    this.lastIncrementalBackup = Date.now();
                    console.log(`‚úÖ Incremental backup: ${scansToBackup.length} scans`);
                    this.updateBackupStatus();
                    
                } catch (error) {
                    console.log('Incremental backup failed, re-queueing scans:', error);
                    this.pendingScans = [...scansToBackup, ...this.pendingScans];
                } finally {
                    this.isBackupRunning = false;
                }
            }

            async runFullBackup() {
                if (window.appData.scanning) {
                    console.log('‚è∏Ô∏è Full backup deferred - scanning in progress');
                    return false;
                }

                this.isBackupRunning = true;

                try {
                    if (!database) throw new Error('Firebase not available');
                    
                    const backupData = {
                        activeBowls: [...window.appData.activeBowls],
                        preparedBowls: [...window.appData.preparedBowls],
                        returnedBowls: [...window.appData.returnedBowls],
                        myScans: [...window.appData.myScans],
                        scanHistory: [...window.appData.scanHistory],
                        lastSync: new Date().toISOString(),
                        lastUpdatedBy: window.appData.user || 'System',
                        backupType: 'full',
                        timestamp: new Date().toISOString()
                    };

                    await Promise.all([
                        set(ref(database, 'appData'), backupData),
                        set(ref(database, 'lastBackupTime'), new Date().toISOString())
                    ]);

                    this.lastFullBackup = Date.now();
                    lastBackupTime = new Date().toISOString();
                    updateBackupDisplay();
                    
                    console.log('‚úÖ Full backup completed');
                    this.updateBackupStatus();
                    return true;
                    
                } catch (error) {
                    console.log('Full backup failed:', error);
                    throw error;
                } finally {
                    this.isBackupRunning = false;
                }
            }

            startSmartTimer() {
                if (this.backupTimer) {
                    clearInterval(this.backupTimer);
                }

                this.backupTimer = setInterval(() => {
                    const conditions = [
                        !window.appData.scanning,
                        isUserActive(),
                        !this.isBackupRunning
                    ];

                    if (conditions.every(Boolean)) {
                        if (this.pendingScans.length > 0) {
                            this.runIncrementalBackup();
                        }
                        
                        if (Date.now() - this.lastFullBackup > 300000) {
                            this.runFullBackup();
                        }
                    }
                }, 60000);
            }

            async onStopScanning() {
                console.log('üîÑ Manual backup triggered by stop scanning');
                
                if (this.pendingScans.length > 0) {
                    await this.runIncrementalBackup();
                }
                
                const result = await this.runFullBackup();
                
                if (result) {
                    showMessage('‚úÖ Backup completed', 'success');
                }
            }

            updateBackupStatus() {
                const backupStatus = document.getElementById('backupStatus');
                if (this.pendingScans.length > 0) {
                    backupStatus.innerHTML = `üíæ Backup active ‚Ä¢ ${this.pendingScans.length} scans queued`;
                } else {
                    backupStatus.innerHTML = `üíæ Backup ready ‚Ä¢ No pending scans`;
                }
            }
        }

        // SMART MERGE FUNCTIONS FOR MULTI-DEVICE SYNC
        function mergeBowls(localBowls, firebaseBowls) {
            const merged = [...localBowls];
            const firebaseCodes = new Set(firebaseBowls.map(bowl => bowl.code + bowl.timestamp));
            
            // Add Firebase bowls that we don't have locally
            firebaseBowls.forEach(fbBowl => {
                const key = fbBowl.code + fbBowl.timestamp;
                const exists = localBowls.some(localBowl => 
                    localBowl.code + localBowl.timestamp === key
                );
                if (!exists) {
                    merged.push(fbBowl);
                }
            });
            
            return merged;
        }

        function mergeScans(localScans, firebaseScans) {
            const merged = [...localScans];
            const firebaseKeys = new Set(firebaseScans.map(scan => scan.code + scan.timestamp));
            
            // Add Firebase scans that we don't have locally
            firebaseScans.forEach(fbScan => {
                const key = fbScan.code + fbScan.timestamp;
                const exists = localScans.some(localScan => 
                    localScan.code + localScan.timestamp === key
                );
                if (!exists) {
                    merged.push(fbScan);
                }
            });
            
            // Sort by timestamp (newest first)
            return merged.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
        }

        const backupSystem = new SmartBackupSystem();

        function initializeFirebase() {
            try {
                app = initializeApp(firebaseConfig);
                database = getDatabase(app);
                setupFirebaseListeners();
                backupSystem.startSmartTimer();
                startDailyCleanupTimer();
                
                loadLastBackupTime();
                
                setTimeout(() => {
                    showMessage('‚úÖ HYBRID SYNC ACTIVE ‚Ä¢ Multi-device sync enabled', 'success');
                    document.getElementById('systemStatus').textContent = '‚úÖ HYBRID SYNC ACTIVE ‚Ä¢ Multi-device sync enabled';
                    backupSystem.updateBackupStatus();
                    checkFirebaseStatus();
                }, 2000);
                
            } catch (error) {
                console.log('Firebase initialization failed:', error);
                showMessage('‚ö†Ô∏è Offline mode - scanning works locally', 'warning');
                document.getElementById('systemStatus').textContent = '‚ö†Ô∏è Offline mode - Scanning works locally';
            }
        }

        function checkFirebaseStatus() {
            const systemStatus = document.getElementById('systemStatus');
            const syncInfo = document.getElementById('syncInfo');
            
            if (database) {
                systemStatus.innerHTML = '‚úÖ Firebase Connected ‚Ä¢ Real-time sync active';
                syncInfo.innerHTML = `<strong>Sync Status:</strong> Connected to Firebase ‚Ä¢ All devices will sync automatically`;
            } else {
                systemStatus.innerHTML = '‚ùå Firebase Disconnected ‚Ä¢ Using local data only';
                syncInfo.innerHTML = `<strong>Sync Status:</strong> Offline mode ‚Ä¢ Data saved locally only`;
            }
        }

        function setupFirebaseListeners() {
            if (!database) return;

            const appDataRef = ref(database, 'appData');
            onValue(appDataRef, (snapshot) => {
                const firebaseAppData = snapshot.val();
                console.log('üì° Firebase Data Received:', firebaseAppData);
                
                if (firebaseAppData && !isSyncing) {
                    isSyncing = true;
                    lastFirebaseUpdate = new Date();
                    
                    console.log('üîÑ SYNC: Merging data from Firebase');
                    console.log('Local active bowls:', window.appData.activeBowls.length);
                    console.log('Firebase active bowls:', firebaseAppData.activeBowls?.length || 0);
                    
                    // MERGE instead of REPLACE - Key fix for multi-device sync
                    window.appData.activeBowls = mergeBowls(window.appData.activeBowls, firebaseAppData.activeBowls || []);
                    window.appData.preparedBowls = mergeBowls(window.appData.preparedBowls, firebaseAppData.preparedBowls || []);
                    window.appData.returnedBowls = mergeBowls(window.appData.returnedBowls, firebaseAppData.returnedBowls || []);
                    window.appData.myScans = mergeScans(window.appData.myScans, firebaseAppData.myScans || []);
                    window.appData.scanHistory = mergeScans(window.appData.scanHistory, firebaseAppData.scanHistory || []);
                    
                    updateDisplay();
                    updateDishStatistics();
                    updateUserAssignments();
                    saveToStorage();
                    
                    console.log('‚úÖ SYNC: Data merged successfully');
                    console.log('Merged active bowls:', window.appData.activeBowls.length);
                    
                    isSyncing = false;
                }
            });

            const backupTimeRef = ref(database, 'lastBackupTime');
            onValue(backupTimeRef, (snapshot) => {
                lastBackupTime = snapshot.val();
                updateBackupDisplay();
            });
        }

        // DAILY CLEANUP SYSTEM
        function startDailyCleanupTimer() {
            checkAndRunCleanup();
            
            setInterval(() => {
                checkAndRunCleanup();
            }, 60000);
        }

        function checkAndRunCleanup() {
            const now = new Date();
            const today = now.toLocaleDateString('en-GB');
            
            const shouldCleanup = (
                (now.getHours() === 19 && now.getMinutes() === 0) ||
                (now.getHours() >= 19 && window.appData.lastCleanup !== today)
            );
            
            if (shouldCleanup) {
                runFirebaseCleanup();
            }
        }

        async function runFirebaseCleanup() {
            if (!database) {
                console.log('‚ùå Firebase not available for cleanup');
                return;
            }

            const today = new Date().toLocaleDateString('en-GB');
            
            try {
                console.log('üßπ RUNNING FIREBASE CLEANUP AT 7:00 PM...');
                
                const appDataRef = ref(database, 'appData');
                const snapshot = await get(appDataRef);
                const currentData = snapshot.val() || {};
                
                const backupData = {
                    returnedBowls: currentData.returnedBowls || [],
                    cleanupDate: today,
                    cleanupTime: new Date().toISOString(),
                    returnedCount: currentData.returnedBowls ? currentData.returnedBowls.length : 0
                };
                
                const backupRef = ref(database, `cleanupBackups/${today}`);
                await set(backupRef, backupData);
                
                const updatedData = {
                    ...currentData,
                    returnedBowls: [],
                    lastCleanup: today,
                    lastCleanupTime: new Date().toISOString()
                };
                
                await set(appDataRef, updatedData);
                
                console.log('‚úÖ Firebase cleanup completed - returned bowls cleared');
                
                window.appData.returnedBowls = [];
                window.appData.lastCleanup = today;
                saveToStorage();
                updateDisplay();
                updateDishStatistics();
                updateUserAssignments();
                
                showMessage(`‚úÖ 7:00 PM Cleanup: Cleared ${backupData.returnedCount} returned bowls ‚Ä¢ Active bowls preserved`, 'success');
                
            } catch (error) {
                console.log('‚ùå Firebase cleanup failed:', error);
            }
        }

        function syncToFirebase() {
            return backupSystem.runFullBackup();
        }

        async function loadFromFirebase() {
            if (!database) {
                showMessage('‚ùå Firebase not available', 'error');
                return;
            }
            
            try {
                const appDataRef = ref(database, 'appData');
                const snapshot = await get(appDataRef);
                const data = snapshot.val();
                
                if (data) {
                    window.appData.activeBowls = data.activeBowls || [];
                    window.appData.preparedBowls = data.preparedBowls || [];
                    window.appData.returnedBowls = data.returnedBowls || [];
                    window.appData.myScans = data.myScans || [];
                    window.appData.scanHistory = data.scanHistory || [];
                    
                    updateDisplay();
                    updateDishStatistics();
                    updateUserAssignments();
                    saveToStorage();
                    
                    showMessage('‚úÖ Data loaded from Firebase backup', 'success');
                } else {
                    showMessage('‚ÑπÔ∏è No data found in Firebase', 'info');
                }
            } catch (error) {
                showMessage('‚ùå Error loading from Firebase', 'error');
            }
        }

        // FORCE SYNC ALL DEVICES
        async function forceAllDevicesSync() {
            if (!database) {
                showMessage('‚ùå Firebase not available', 'error');
                return;
            }
            
            const btn = document.getElementById('forceSyncBtn');
            btn.disabled = true;
            btn.textContent = "üîÑ SYNCING...";
            
            try {
                // Force read from Firebase
                await loadFromFirebase();
                
                // Force write to Firebase
                await syncToFirebase();
                
                showMessage('‚úÖ Forced sync completed - all devices should update', 'success');
                
            } catch (error) {
                showMessage('‚ùå Force sync failed', 'error');
            } finally {
                btn.disabled = false;
                btn.textContent = "üîÑ FORCE SYNC ALL DEVICES";
            }
        }

        function loadLastBackupTime() {
            if (!database) return;
            
            const backupTimeRef = ref(database, 'lastBackupTime');
            onValue(backupTimeRef, (snapshot) => {
                lastBackupTime = snapshot.val();
                updateBackupDisplay();
            });
        }

        function updateBackupDisplay() {
            const backupInfo = document.getElementById('backupInfo');
            
            if (lastBackupTime) {
                const backupDate = new Date(lastBackupTime);
