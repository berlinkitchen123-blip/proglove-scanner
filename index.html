<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ProGlove Scanner - Complete System</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: Arial, sans-serif; background: #1a1a1a; color: white; padding: 10px; }
        .container { max-width: 100%; margin: 0 auto; display: flex; flex-direction: column; gap: 15px; }
        .header { background: #4285f4; padding: 15px; text-align: center; border-radius: 10px; }
        .card { background: #2a2a2a; padding: 15px; border-radius: 10px; margin-bottom: 10px; }
        .sync-section { background: #333; padding: 15px; border-radius: 8px; margin-bottom: 15px; }
        .sync-controls { display: flex; gap: 10px; margin-bottom: 10px; }
        .sync-btn { flex: 1; padding: 12px; border: none; border-radius: 6px; font-size: 14px; font-weight: bold; cursor: pointer; }
        .download-btn { background: #4285f4; color: white; }
        .upload-btn { background: #34a853; color: white; }
        .export-btn { background: #f57c00; color: white; }
        .emergency-btn { background: #ea4335; color: white; }
        .sync-btn:disabled { background: #666; cursor: not-allowed; }
        .system-status { padding: 10px; margin-top: 10px; border-radius: 5px; text-align: center; font-size: 12px; background: #444; border-left: 4px solid #f57c00; }
        .sync-status { padding: 10px; margin-top: 10px; border-radius: 5px; text-align: center; font-size: 12px; background: #444; border-left: 4px solid #4285f4; }
        .sync-status.success { border-left-color: #34a853; background: #2a2a2a; }
        .sync-status.error { border-left-color: #ea4335; background: #2a2a2a; }
        .mode-buttons { display: flex; gap: 10px; margin-bottom: 15px; }
        .mode-btn { flex: 1; padding: 15px; border: none; border-radius: 8px; font-size: 16px; font-weight: bold; cursor: pointer; }
        .kitchen-btn { background: #34a853; color: white; }
        .return-btn { background: #ea4335; color: white; }
        .mode-btn.active { box-shadow: 0 0 0 3px white; }
        .dropdown { width: 100%; padding: 12px; background: #444; color: white; border: 2px solid #666; border-radius: 6px; font-size: 16px; margin-top: 10px; }
        .scan-controls { display: flex; gap: 10px; margin-bottom: 15px; }
        .scan-btn { flex: 1; padding: 15px; border: none; border-radius: 8px; font-size: 16px; font-weight: bold; cursor: pointer; }
        .start-btn { background: #34a853; color: white; }
        .stop-btn { background: #ea4335; color: white; }
        .scan-btn:disabled { background: #666; cursor: not-allowed; }
        .proglove-input { width: 100%; padding: 15px; font-size: 18px; background: #333; color: white; border: 2px solid #666; border-radius: 8px; margin-bottom: 15px; text-align: center; }
        .proglove-input.error { border-color: #ea4335; animation: shake 0.5s; }
        .scanning-active { animation: pulse 1.5s infinite; border: 3px solid #34a853; }
        .feedback { padding: 12px; margin-top: 10px; border-radius: 6px; text-align: center; font-weight: bold; min-height: 50px; display: flex; align-items: center; justify-content: center; }
        .success { background: #34a853; }
        .error { background: #ea4335; }
        .warning { background: #f57c00; }
        .info { background: #4285f4; }
        .hidden { display: none; }
        .stats-grid { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; margin-bottom: 15px; }
        .stat-item { background: #333; padding: 15px; border-radius: 8px; text-align: center; }
        .stat-value { font-size: 24px; font-weight: bold; }
        .kitchen-stat { color: #34a853; }
        .return-stat { color: #ea4335; }
        .active-stat { color: #4285f4; }
        .prep-stat { color: #f57c00; }
        .response-time { font-size: 12px; color: #888; text-align: center; margin-top: 5px; }
        .local-data { background: #2a2a2a; padding: 10px; border-radius: 5px; margin-top: 10px; font-size: 12px; border-left: 4px solid #f57c00; }
        .upload-info { background: #2a2a2a; padding: 10px; border-radius: 5px; margin-top: 10px; font-size: 12px; border-left: 4px solid #4285f4; }
        .cross-team-data { background: #2a2a2a; padding: 10px; border-radius: 5px; margin-top: 10px; font-size: 12px; border-left: 4px solid #f57c00; }
        .data-row { display: flex; justify-content: space-between; margin-bottom: 5px; }
        .data-label { font-weight: bold; }
        .admin-section { border: 2px solid #f57c00; }
        .backup-status { background: #2a2a2a; padding: 8px; border-radius: 5px; margin-top: 5px; font-size: 11px; border-left: 4px solid #34a853; }
        .device-lock { background: #ff9800; padding: 8px; border-radius: 5px; margin-top: 5px; font-size: 11px; border-left: 4px solid #ff9800; }
        
        /* Dish Statistics Table Styles */
        .dish-stats-table { 
            width: 100%; 
            border-collapse: collapse; 
            margin-top: 10px;
            font-size: 11px;
        }
        .dish-stats-table th {
            background: #4285f4;
            color: white;
            padding: 6px;
            text-align: center;
            border: 1px solid #555;
        }
        .dish-stats-table td {
            padding: 6px;
            text-align: center;
            border: 1px solid #555;
            background: #333;
        }
        .dish-stats-table .dish-header {
            background: #34a853;
            font-weight: bold;
        }
        .dish-stats-table .total-row {
            background: #f57c00;
            font-weight: bold;
        }
        .dish-stats-table .expected-highlight {
            background: #ffeb3b;
            color: #000;
            font-weight: bold;
        }
        .dish-stats-table .missing {
            background: #ff4444;
            color: white;
            font-weight: bold;
        }
        .dish-stats-table .extra {
            background: #ff9800;
            color: white;
            font-weight: bold;
        }
        .dish-stats-table .time-info {
            font-size: 9px;
            color: #ccc;
        }
        .dish-stats-table .prepared-by {
            font-size: 9px;
            color: #88ff88;
        }

        @keyframes pulse { 0% { box-shadow: 0 0 0 0 rgba(52, 168, 83, 0.7); } 70% { box-shadow: 0 0 0 15px rgba(52, 168, 83, 0); } 100% { box-shadow: 0 0 0 0 rgba(52, 168, 83, 0); } }
        @keyframes shake { 0%, 100% { transform: translateX(0); } 25% { transform: translateX(-5px); } 75% { transform: translateX(5px); } }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üß§ ProGlove Scanner - Complete System</h1>
            <p>Multi-Device ‚Ä¢ Device Locking ‚Ä¢ Auto Timeout</p>
        </div>
        
        <div class="card">
            <h3>üìä SYSTEM STATUS</h3>
            <div class="system-status" id="systemStatus">
                üîÑ Connecting to cloud...
            </div>
            <div class="backup-status" id="backupStatus">
                üíæ Sync active
            </div>
            <div class="device-lock" id="deviceLockStatus">
                üîì No active scanner
            </div>
        </div>

        <div class="card">
            <h3>üì± SELECT MODE</h3>
            <div class="mode-buttons">
                <button class="mode-btn kitchen-btn" onclick="setMode('kitchen')" id="kitchenBtn">üç≥ KITCHEN</button>
                <button class="mode-btn return-btn" onclick="setMode('return')" id="returnBtn">üîÑ RETURN</button>
            </div>
        </div>
        
        <div class="card">
            <h3>üë§ SELECT USER</h3>
            <select class="dropdown" id="userDropdown" onchange="selectUser()">
                <option value="">-- Select User --</option>
            </select>
        </div>
        
        <div class="card hidden" id="dishSection">
            <h3>üìù SELECT DISH LETTER</h3>
            <select class="dropdown" id="dishDropdown" onchange="selectDishLetter()">
                <option value="">-- Select Dish Letter --</option>
            </select>
        </div>
        
        <div class="card hidden" id="crossTeamDataSection">
            <h3>üìä LIVE BOWL STATUS</h3>
            <div class="cross-team-data" id="crossTeamData">
                No active bowls yet
            </div>
        </div>
        
        <div class="card" id="scanSection">
            <h3>üîç SCANNING</h3>
            <div class="scan-controls">
                <button class="scan-btn start-btn" id="startBtn" onclick="requestScanningAccess()">‚ñ∂ START SCANNING</button>
                <button class="scan-btn stop-btn" id="stopBtn" onclick="stopScanning()">‚èπ STOP SCANNING</button>
            </div>
            
            <input type="text" class="proglove-input" id="progloveInput" placeholder="Click START SCANNING to begin..." disabled>
            
            <div class="response-time">
                Response time: <span id="responseTimeValue">0</span>ms ‚Ä¢ 
                Timeout: <span id="timeoutCounter">120</span>s
            </div>
            
            <div class="stats-grid">
                <div class="stat-item">
                    <div class="stat-label">Active Bowls</div>
                    <div class="stat-value active-stat" id="activeCount">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label" id="prepLabel">Prepared Today</div>
                    <div class="stat-value prep-stat" id="prepCount">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">My Scans Today</div>
                    <div class="stat-value kitchen-stat" id="myScansCount">0</div>
                </div>
            </div>
            
            <div class="feedback info" id="feedback">
                ‚úÖ System ready - Select mode and user to start
            </div>
        </div>

        <!-- DISH SCANNING STATISTICS TABLE -->
        <div class="card">
            <h3>üìà DISH SCANNING STATISTICS</h3>
            <div style="background: #444; padding: 10px; border-radius: 5px; margin-bottom: 10px;">
                <small>‚ÑπÔ∏è Real-time tracking of scanned dishes</small>
            </div>
            <div id="dishStatistics">
                <table class="dish-stats-table">
                    <thead>
                        <tr>
                            <th>Dish</th>
                            <th>Prepared By</th>
                            <th>Scanned</th>
                            <th>Expected</th>
                            <th>Difference</th>
                            <th>First Scan</th>
                            <th>Last Scan</th>
                            <th>Status</th>
                        </tr>
                    </thead>
                    <tbody id="dishStatsBody">
                        <!-- Statistics will be populated here -->
                    </tbody>
                </table>
            </div>
            <div class="local-data" style="margin-top: 10px;">
                <strong>Last Updated:</strong> <span id="statsUpdateTime">Never</span>
            </div>
        </div>

        <!-- DATA RECOVERY SECTION -->
        <div class="card admin-section">
            <h3>üîÑ DATA RECOVERY & RESET</h3>
            <div style="background: #444; padding: 10px; border-radius: 5px; margin-bottom: 10px;">
                <small>‚ÑπÔ∏è Consolidate all data from today until 9AM</small>
            </div>
            <div class="sync-controls">
                <button class="sync-btn upload-btn" onclick="consolidateTodayData()" id="consolidateBtn">
                    üì• CONSOLIDATE TODAY'S DATA
                </button>
                <button class="sync-btn emergency-btn" onclick="forceReleaseLock()" id="forceReleaseBtn">
                    üîì FORCE RELEASE LOCK
                </button>
            </div>
            <div class="local-data" id="recoveryInfo">
                <strong>Recovery Status:</strong> Ready to consolidate data
            </div>
        </div>

        <!-- EXCEL EXPORT SECTION -->
        <div class="card">
            <h3>üìä EXCEL EXPORT</h3>
            <div class="sync-section">
                <div class="sync-controls">
                    <button class="sync-btn export-btn" onclick="exportToExcel()" id="exportBtn">
                        üì§ EXPORT TO EXCEL
                    </button>
                </div>
                <div class="sync-status" id="syncStatus">
                    ‚úÖ Excel export ready
                </div>
                <div class="local-data" id="localDataInfo">
                    <strong>Current Data:</strong> Loading...
                </div>
            </div>
        </div>
    </div>

    <!-- Firebase Configuration -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/12.4.0/firebase-app.js";
        import { getDatabase, ref, set, onValue, get, update } from "https://www.gstatic.com/firebasejs/12.4.0/firebase-database.js";

        const firebaseConfig = {
            apiKey: "AIzaSyCL3hffCHosBceIRGR1it2dYEDb3uxIrJw",
            authDomain: "proglove-scanner.firebaseapp.com",
            databaseURL: "https://proglove-scanner-default-rtdb.europe-west1.firebasedatabase.app",
            projectId: "proglove-scanner",
            storageBucket: "proglove-scanner.firebasestorage.app",
            messagingSenderId: "177575768177",
            appId: "1:177575768177:web:0a0acbf222218e0c0b2bd0"
        };

        let app;
        let database;
        let deviceId = 'device_' + Math.random().toString(36).substr(2, 9);
        let timeoutTimer;
        let countdownTimer;

        // DEVICE LOCKING SYSTEM
        class DeviceLockSystem {
            constructor() {
                this.lockCheckInterval = null;
                this.isLocked = false;
            }

            async requestLock() {
                if (!database) return false;

                try {
                    const lockRef = ref(database, 'deviceLock');
                    const snapshot = await get(lockRef);
                    const currentLock = snapshot.val();

                    // If no lock or lock expired (2 minutes + buffer)
                    if (!currentLock || this.isLockExpired(currentLock)) {
                        const lockData = {
                            deviceId: deviceId,
                            user: window.appData.user,
                            timestamp: Date.now(),
                            mode: window.appData.mode,
                            dishLetter: window.appData.dishLetter
                        };

                        await set(lockRef, lockData);
                        this.isLocked = true;
                        this.startLockMonitoring();
                        console.log('üîí Lock acquired by', deviceId);
                        return true;
                    } else {
                        console.log('üîê Lock held by', currentLock.deviceId);
                        return false;
                    }
                } catch (error) {
                    console.error('Lock request failed:', error);
                    return false;
                }
            }

            async releaseLock() {
                if (!database || !this.isLocked) return;

                try {
                    const lockRef = ref(database, 'deviceLock');
                    const snapshot = await get(lockRef);
                    const currentLock = snapshot.val();

                    // Only release if we hold the lock
                    if (currentLock && currentLock.deviceId === deviceId) {
                        await set(lockRef, null);
                        this.isLocked = false;
                        this.stopLockMonitoring();
                        console.log('üîì Lock released by', deviceId);
                    }
                } catch (error) {
                    console.error('Lock release failed:', error);
                }
            }

            isLockExpired(lock) {
                return Date.now() - lock.timestamp > 130000; // 2 minutes 10 seconds
            }

            startLockMonitoring() {
                this.lockCheckInterval = setInterval(async () => {
                    const lockRef = ref(database, 'deviceLock');
                    onValue(lockRef, (snapshot) => {
                        const lock = snapshot.val();
                        this.updateLockDisplay(lock);
                    });
                }, 5000);
            }

            stopLockMonitoring() {
                if (this.lockCheckInterval) {
                    clearInterval(this.lockCheckInterval);
                }
                this.updateLockDisplay(null);
            }

            updateLockDisplay(lock) {
                const lockStatus = document.getElementById('deviceLockStatus');
                if (!lock) {
                    lockStatus.innerHTML = 'üîì No active scanner';
                    lockStatus.style.borderLeftColor = '#34a853';
                } else if (lock.deviceId === deviceId) {
                    const timeElapsed = Math.floor((Date.now() - lock.timestamp) / 1000);
                    lockStatus.innerHTML = `üîí You are scanning ‚Ä¢ ${120 - timeElapsed}s left`;
                    lockStatus.style.borderLeftColor = '#4285f4';
                } else {
                    lockStatus.innerHTML = `üîê ${lock.user} is scanning ‚Ä¢ Wait your turn`;
                    lockStatus.style.borderLeftColor = '#ff9800';
                }
            }

            async forceReleaseLock() {
                if (!database) return;

                try {
                    const lockRef = ref(database, 'deviceLock');
                    await set(lockRef, null);
                    this.isLocked = false;
                    this.stopLockMonitoring();
                    console.log('üîì Lock force released');
                    showMessage('‚úÖ Lock force released', 'success');
                } catch (error) {
                    console.error('Force release failed:', error);
                    showMessage('‚ùå Force release failed', 'error');
                }
            }
        }

        const deviceLock = new DeviceLockSystem();

        function initializeFirebase() {
            try {
                app = initializeApp(firebaseConfig);
                database = getDatabase(app);
                setupFirebaseListeners();
                
                setTimeout(() => {
                    showMessage('‚úÖ Firebase Connected ‚Ä¢ Device locking active', 'success');
                    document.getElementById('systemStatus').textContent = '‚úÖ Firebase Connected ‚Ä¢ Device locking active';
                }, 2000);
                
            } catch (error) {
                console.log('Firebase initialization failed:', error);
                showMessage('‚ö†Ô∏è Offline mode - limited functionality', 'warning');
                document.getElementById('systemStatus').textContent = '‚ö†Ô∏è Offline mode - Limited functionality';
            }
        }

        function setupFirebaseListeners() {
            if (!database) return;

            // Listen for app data
            const appDataRef = ref(database, 'appData');
            onValue(appDataRef, (snapshot) => {
                const firebaseAppData = snapshot.val();
                if (firebaseAppData) {
                    window.appData.activeBowls = firebaseAppData.activeBowls || [];
                    window.appData.preparedBowls = firebaseAppData.preparedBowls || [];
                    window.appData.returnedBowls = firebaseAppData.returnedBowls || [];
                    window.appData.myScans = firebaseAppData.myScans || [];
                    window.appData.scanHistory = firebaseAppData.scanHistory || [];
                    
                    updateDisplay();
                    updateDishStatistics();
                    saveToStorage();
                }
            });

            // Listen for device lock
            const lockRef = ref(database, 'deviceLock');
            onValue(lockRef, (snapshot) => {
                const lock = snapshot.val();
                deviceLock.updateLockDisplay(lock);
                
                // Update UI based on lock status
                if (lock && lock.deviceId !== deviceId) {
                    document.getElementById('startBtn').disabled = true;
                    document.getElementById('startBtn').textContent = `‚è∏Ô∏è ${lock.user} IS SCANNING`;
                } else {
                    document.getElementById('startBtn').disabled = !canStartScanning();
                    document.getElementById('startBtn').textContent = '‚ñ∂ START SCANNING';
                }
            });
        }

        window.initializeFirebase = initializeFirebase;
        window.deviceLock = deviceLock;
    </script>

    <!-- Main Application Logic -->
    <script>
        // ProGlove Scanner - DEVICE LOCKING SYSTEM
        window.appData = {
            mode: null,
            user: null,
            dishLetter: null,
            scanning: false,
            myScans: [],
            activeBowls: [],
            preparedBowls: [],
            returnedBowls: [],
            scanHistory: [],
            expectedCounts: {},
            lastActivity: Date.now()
        };

        const USERS = [
            {name: "Hamid", role: "Kitchen"},
            {name: "Richa", role: "Kitchen"},
            {name: "Mary", role: "Kitchen"},
            {name: "Jash", role: "Kitchen"},
            {name: "Joel", role: "Kitchen"},
            {name: "Rushal", role: "Kitchen"},
            {name: "Sreekanth", role: "Kitchen"},
            {name: "M.Sultan", role: "Return"},
            {name: "Riyaz", role: "Return"},
            {name: "Alan", role: "Return"},
            {name: "Aadesh", role: "Return"},
            {name: "Kitchen Team", role: "Return"}
        ];

        // SIMPLE DATE FUNCTION
        function isToday(timestamp) {
            const today = new Date().toDateString();
            const scanDate = new Date(timestamp).toDateString();
            return today === scanDate;
        }

        // AUTO TIMEOUT SYSTEM
        function startTimeoutTimer() {
            let timeLeft = 120; // 2 minutes
            updateTimeoutDisplay(timeLeft);
            
            // Clear existing timers
            if (timeoutTimer) clearTimeout(timeoutTimer);
            if (countdownTimer) clearInterval(countdownTimer);
            
            // Countdown display
            countdownTimer = setInterval(() => {
                timeLeft--;
                updateTimeoutDisplay(timeLeft);
                
                if (timeLeft <= 0) {
                    clearInterval(countdownTimer);
                    autoStopScanning();
                }
            }, 1000);
            
            // Main timeout
            timeoutTimer = setTimeout(() => {
                autoStopScanning();
            }, 120000);
        }

        function resetTimeoutTimer() {
            window.appData.lastActivity = Date.now();
            startTimeoutTimer();
        }

        function stopTimeoutTimer() {
            if (timeoutTimer) clearTimeout(timeoutTimer);
            if (countdownTimer) clearInterval(countdownTimer);
            updateTimeoutDisplay(120);
        }

        function updateTimeoutDisplay(seconds) {
            const counter = document.getElementById('timeoutCounter');
            if (counter) {
                counter.textContent = seconds;
                
                // Color coding
                if (seconds <= 30) {
                    counter.style.color = '#ea4335';
                } else if (seconds <= 60) {
                    counter.style.color = '#f57c00';
                } else {
                    counter.style.color = '#34a853';
                }
            }
        }

        function autoStopScanning() {
            if (window.appData.scanning) {
                console.log('‚è∞ Auto-stopping scanning due to inactivity');
                stopScanning();
                showMessage('‚è∞ Scanning auto-stopped after 2 minutes of inactivity', 'warning');
            }
        }

        // DATA CONSOLIDATION
        async function consolidateTodayData() {
            if (!database) {
                showMessage('‚ùå Firebase not available', 'error');
                return;
            }

            const btn = document.getElementById('consolidateBtn');
            btn.disabled = true;
            btn.textContent = "üîÑ CONSOLIDATING...";

            try {
                // Get current data
                const appDataRef = ref(database, 'appData');
                const snapshot = await get(appDataRef);
                const currentData = snapshot.val() || {};

                // Filter only today's data
                const today = new Date().toDateString();
                const consolidatedData = {
                    activeBowls: (currentData.activeBowls || []).filter(bowl => 
                        new Date(bowl.timestamp).toDateString() === today
                    ),
                    preparedBowls: (currentData.preparedBowls || []).filter(bowl => 
                        new Date(bowl.timestamp).toDateString() === today
                    ),
                    returnedBowls: (currentData.returnedBowls || []).filter(bowl => 
                        new Date(bowl.returnTimestamp || bowl.timestamp).toDateString() === today
                    ),
                    myScans: (currentData.myScans || []).filter(scan => 
                        new Date(scan.timestamp).toDateString() === today
                    ),
                    scanHistory: (currentData.scanHistory || []).filter(record => 
                        new Date(record.timestamp).toDateString() === today
                    ),
                    lastConsolidation: new Date().toISOString(),
                    consolidatedBy: window.appData.user || 'System'
                };

                // Write consolidated data
                await set(appDataRef, consolidatedData);
                
                // Update local data
                window.appData = { ...window.appData, ...consolidatedData };
                updateDisplay();
                updateDishStatistics();
                saveToStorage();

                showMessage('‚úÖ Today\'s data consolidated successfully!', 'success');
                document.getElementById('recoveryInfo').innerHTML = 
                    '<strong>Recovery Status:</strong> ‚úÖ Data consolidated ‚Ä¢ Ready for scanning';

            } catch (error) {
                console.error('Consolidation failed:', error);
                showMessage('‚ùå Data consolidation failed', 'error');
            } finally {
                btn.disabled = false;
                btn.textContent = "üì• CONSOLIDATE TODAY'S DATA";
            }
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            console.log('Initializing Scanner System with Device Locking...');
            initializeFirebase();
            loadFromStorage();
            initializeUsers();
            updateDisplay();
            updateDishStatistics();
            
            document.getElementById('progloveInput').addEventListener('input', handleScanInput);
            document.addEventListener('click', resetTimeoutTimer);
            document.addEventListener('keydown', resetTimeoutTimer);
        });

        // Storage functions
        function saveToStorage() {
            try {
                localStorage.setItem('proglove_data', JSON.stringify(window.appData));
            } catch (error) {
                console.log('Storage save error:', error);
            }
        }

        function loadFromStorage() {
            try {
                const saved = localStorage.getItem('proglove_data');
                if (saved) {
                    const data = JSON.parse(saved);
                    window.appData = { ...window.appData, ...data };
                    console.log('Data loaded from storage');
                }
            } catch (error) {
                console.log('No previous data found');
            }
        }

        // User and Mode Management
        function initializeUsers() {
            const dropdown = document.getElementById('userDropdown');
            dropdown.innerHTML = '<option value="">-- Select User --</option>';
            
            USERS.forEach(user => {
                const option = document.createElement('option');
                option.value = user.name;
                option.textContent = user.name + (user.role ? ` (${user.role})` : '');
                dropdown.appendChild(option);
            });
        }

        function setMode(mode) {
            window.appData.mode = mode;
            window.appData.user = null;
            window.appData.dishLetter = null;
            window.appData.scanning = false;
            
            document.getElementById('kitchenBtn').classList.toggle('active', mode === 'kitchen');
            document.getElementById('returnBtn').classList.toggle('active', mode === 'return');
            
            document.getElementById('dishSection').classList.toggle('hidden', mode !== 'kitchen');
            document.getElementById('crossTeamDataSection').classList.remove('hidden');
            document.getElementById('userDropdown').value = '';
            document.getElementById('dishDropdown').value = '';
            document.getElementById('progloveInput').value = '';
            
            loadUsers();
            updateStatsLabels();
            updateDisplay();
            showMessage(`üì± ${mode.toUpperCase()} mode selected`, 'info');
        }

        function canStartScanning() {
            return window.appData.user && 
                   (!window.appData.scanning) &&
                   (window.appData.mode !== 'kitchen' || window.appData.dishLetter);
        }

        // REQUEST SCANNING ACCESS WITH DEVICE LOCK
        async function requestScanningAccess() {
            if (!canStartScanning()) {
                showMessage('‚ùå Please select user and dish letter first', 'error');
                return;
            }

            const lockAcquired = await deviceLock.requestLock();
            if (lockAcquired) {
                startScanning();
            } else {
                showMessage('‚è∏Ô∏è Another device is currently scanning. Please wait...', 'warning');
            }
        }

        function startScanning() {
            window.appData.scanning = true;
            updateDisplay();
            document.getElementById('progloveInput').focus();
            startTimeoutTimer();
            showMessage(`üéØ SCANNING ACTIVE - You have 2 minutes`, 'success');
        }

        // FIXED: Stop Scanning button now always works and instantly uploads data
        async function stopScanning() {
            if (!window.appData.scanning) {
                showMessage('‚ÑπÔ∏è Scanning is not active', 'info');
                return;
            }
            
            console.log('üõë Manual stop scanning requested');
            window.appData.scanning = false;
            await deviceLock.releaseLock();
            stopTimeoutTimer();
            updateDisplay();
            syncToFirebase();
            showMessage(`‚èπ Scanning stopped ‚Ä¢ Data saved to cloud`, 'success');
        }

        function forceReleaseLock() {
            deviceLock.forceReleaseLock();
        }

        function updateStatsLabels() {
            const prepLabel = document.getElementById('prepLabel');
            if (window.appData.mode === 'kitchen') {
                prepLabel.textContent = 'Prepared Today';
            } else {
                prepLabel.textContent = 'Returned Today';
            }
        }

        function loadUsers() {
            const dropdown = document.getElementById('userDropdown');
            dropdown.innerHTML = '<option value="">-- Select User --</option>';
            
            let usersToShow = [];
            if (window.appData.mode === 'kitchen') {
                usersToShow = USERS.filter(user => user.role === 'Kitchen');
            } else if (window.appData.mode === 'return') {
                usersToShow = USERS.filter(user => user.role === 'Return' || user.name === "Kitchen Team");
            }
            
            usersToShow.forEach(user => {
                const option = document.createElement('option');
                option.value = user.name;
                option.textContent = user.name + (user.role ? ` (${user.role})` : '');
                dropdown.appendChild(option);
            });
        }

        function loadDishLetters() {
            const dropdown = document.getElementById('dishDropdown');
            dropdown.innerHTML = '<option value="">-- Select Dish Letter --</option>';
            
            'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('').forEach(letter => {
                const option = document.createElement('option');
                option.value = letter;
                option.textContent = letter;
                dropdown.appendChild(option);
            });
            
            '1234'.split('').forEach(number => {
                const option = document.createElement('option');
                option.value = number;
                option.textContent = number;
                dropdown.appendChild(option);
            });
        }

        function selectUser() {
            const dropdown = document.getElementById('userDropdown');
            window.appData.user = dropdown.value;
            
            if (window.appData.user) {
                showMessage(`‚úÖ ${window.appData.user} selected`, 'success');
                if (window.appData.mode === 'kitchen') {
                    document.getElementById('dishSection').classList.remove('hidden');
                    loadDishLetters();
                }
            }
            updateDisplay();
        }

        function selectDishLetter() {
            const dropdown = document.getElementById('dishDropdown');
            window.appData.dishLetter = dropdown.value;
            
            if (window.appData.dishLetter) {
                showMessage(`üìù Dish ${window.appData.dishLetter} selected`, 'success');
            }
            updateDisplay();
        }

        function handleScanInput(e) {
            if (!window.appData.scanning) return;
            
            const scanValue = e.target.value.trim();
            if (scanValue.length >= 2) {
                processScan(scanValue);
                setTimeout(() => e.target.value = '', 100);
            }
            resetTimeoutTimer();
        }

        function processScan(code) {
            let result;
            
            if (window.appData.mode === 'kitchen') {
                result = kitchenScan(code);
            } else {
                result = returnScan(code);
            }
            
            document.getElementById('responseTimeValue').textContent = result.responseTime;
            showMessage(result.message, result.type);
            
            if (result.type === 'error') {
                document.getElementById('progloveInput').classList.add('error');
                setTimeout(() => document.getElementById('progloveInput').classList.remove('error'), 2000);
            }
            
            updateDisplay();
            updateDishStatistics();
            resetTimeoutTimer();
        }

        function kitchenScan(code) {
            const startTime = Date.now();
            const fullCode = code.toUpperCase();
            const today = new Date().toLocaleDateString();
            
            if (window.appData.activeBowls.some(bowl => bowl.code === fullCode)) {
                return { 
                    message: "‚ùå Bowl already active: " + fullCode, 
                    type: "error",
                    responseTime: Date.now() - startTime
                };
            }
            
            if (window.appData.preparedBowls.some(bowl => bowl.code === fullCode && isToday(bowl.timestamp))) {
                return { 
                    message: "‚ùå Already prepared today: " + fullCode, 
                    type: "error",
                    responseTime: Date.now() - startTime
                };
            }
            
            const newBowl = {
                code: fullCode,
                dish: window.appData.dishLetter,
                user: window.appData.user,
                company: "Unknown",
                customer: "Unknown",
                date: today,
                time: new Date().toLocaleTimeString(),
                timestamp: new Date().toISOString(),
                status: 'ACTIVE'
            };
            
            window.appData.activeBowls.push(newBowl);
            window.appData.preparedBowls.push({...newBowl, status: 'PREPARED'});
            
            const scanRecord = {
                type: 'kitchen',
                code: fullCode,
                dish: window.appData.dishLetter,
                user: window.appData.user,
                company: "Unknown",
                customer: "Unknown",
                timestamp: new Date().toISOString()
            };
            
            window.appData.myScans.push(scanRecord);
            
            window.appData.scanHistory.unshift({
                type: 'kitchen',
                code: fullCode,
                user: window.appData.user,
                timestamp: new Date().toISOString(),
                message: `${window.appData.dishLetter} Prepared: ${fullCode}`
            });
            
            saveToStorage();
            syncToFirebase();
            
            return { 
                message: `‚úÖ ${window.appData.dishLetter} Prepared: ${fullCode}`, 
                type: "success",
                responseTime: Date.now() - startTime
            };
        }

        function returnScan(code) {
            const startTime = Date.now();
            const fullCode = code.toUpperCase();
            const today = new Date().toLocaleDateString();
            
            // Check if already returned today
            const alreadyReturned = window.appData.returnedBowls.some(bowl => 
                bowl.code === fullCode && isToday(bowl.returnTimestamp || bowl.timestamp)
            );
            
            if (alreadyReturned) {
                return { 
                    message: "‚úÖ Already returned today: " + fullCode, 
                    type: "success",
                    responseTime: Date.now() - startTime
                };
            }
            
            // Find in active bowls
            const activeBowlIndex = window.appData.activeBowls.findIndex(bowl => bowl.code === fullCode);
            
            if (activeBowlIndex === -1) {
                return { 
                    message: "‚ùå Bowl not found in active bowls: " + fullCode, 
                    type: "error",
                    responseTime: Date.now() - startTime
                };
            }
            
            const activeBowl = window.appData.activeBowls[activeBowlIndex];
            
            // Remove from active bowls
            window.appData.activeBowls.splice(activeBowlIndex, 1);
            
            // Add to returned bowls
            window.appData.returnedBowls.push({
                ...activeBowl,
                returnedBy: window.appData.user,
                returnDate: today,
                returnTime: new Date().toLocaleTimeString(),
                returnTimestamp: new Date().toISOString(),
                status: 'RETURNED'
            });
            
            const scanRecord = {
                type: 'return',
                code: fullCode,
                user: window.appData.user,
                company: activeBowl.company,
                customer: activeBowl.customer,
                timestamp: new Date().toISOString(),
                originalData: activeBowl
            };
            
            window.appData.myScans.push(scanRecord);
            
            window.appData.scanHistory.unshift({
                type: 'return',
                code: fullCode,
                user: window.appData.user,
                timestamp: new Date().toISOString(),
                message: `Returned: ${fullCode}`
            });
            
            saveToStorage();
            syncToFirebase();
            
            return { 
                message: `‚úÖ Returned: ${fullCode} - Removed from active bowls`, 
                type: "success",
                responseTime: Date.now() - startTime
            };
        }

        function syncToFirebase() {
            if (!database) return;
            
            const appDataRef = ref(database, 'appData');
            set(appDataRef, {
                activeBowls: window.appData.activeBowls,
                preparedBowls: window.appData.preparedBowls,
                returnedBowls: window.appData.returnedBowls,
                myScans: window.appData.myScans,
                scanHistory: window.appData.scanHistory,
                lastSync: new Date().toISOString()
            }).then(() => {
                console.log('‚úÖ Data synced to Firebase');
            }).catch(error => {
                console.error('‚ùå Firebase sync failed:', error);
            });
        }

        function updateDisplay() {
            document.getElementById('exportBtn').disabled = window.appData.myScans.length === 0 && window.appData.activeBowls.length === 0;
            
            const input = document.getElementById('progloveInput');
            if (window.appData.scanning) {
                document.getElementById('scanSection').classList.add('scanning-active');
                input.placeholder = "Scan VYT code...";
                input.disabled = false;
                document.getElementById('stopBtn').disabled = false;
            } else {
                document.getElementById('scanSection').classList.remove('scanning-active');
                input.placeholder = "Click START SCANNING...";
                input.disabled = true;
                document.getElementById('stopBtn').disabled = false; // Stop button always enabled
            }
            
            // Count TODAY'S data
            const preparedToday = window.appData.preparedBowls.filter(bowl => isToday(bowl.timestamp)).length;
            const returnedToday = window.appData.returnedBowls.filter(bowl => isToday(bowl.returnTimestamp || bowl.timestamp)).length;
            
            let userTodayScans = 0;
            if (window.appData.user) {
                if (window.appData.mode === 'kitchen' && window.appData.dishLetter) {
                    userTodayScans = window.appData.myScans.filter(scan => 
                        scan.user === window.appData.user && 
                        scan.dish === window.appData.dishLetter &&
                        isToday(scan.timestamp)
                    ).length;
                } else if (window.appData.mode === 'return') {
                    userTodayScans = window.appData.myScans.filter(scan => 
                        scan.user === window.appData.user && 
                        scan.type === 'return' &&
                        isToday(scan.timestamp)
                    ).length;
                }
            }
            
            document.getElementById('activeCount').textContent = window.appData.activeBowls.length;
            
            if (window.appData.mode === 'kitchen') {
                document.getElementById('prepCount').textContent = preparedToday;
                document.getElementById('myScansCount').textContent = userTodayScans;
            } else {
                document.getElementById('prepCount').textContent = returnedToday;
                document.getElementById('myScansCount').textContent = userTodayScans;
            }
            
            document.getElementById('localDataInfo').innerHTML = `
                <strong>Current Data:</strong> 
                ${window.appData.activeBowls.length} active bowls ‚Ä¢ 
                ${preparedToday} prepared today ‚Ä¢ 
                ${returnedToday} returned today ‚Ä¢
                ${window.appData.myScans.length} total scans
            `;
            
            updateCrossTeamData();
        }

        function updateCrossTeamData() {
            const element = document.getElementById('crossTeamData');
            
            const preparedToday = window.appData.preparedBowls.filter(bowl => isToday(bowl.timestamp)).length;
            const returnedToday = window.appData.returnedBowls.filter(bowl => isToday(bowl.returnTimestamp || bowl.timestamp)).length;
            
            if (window.appData.mode === 'kitchen') {
                element.innerHTML = `
                    <div class="data-row"><span class="data-label">Today's Returns:</span><span>${returnedToday} bowls</span></div>
                    <div class="data-row"><span class="data-label">Active Bowls:</span><span>${window.appData.activeBowls.length} bowls</span></div>
                    <div class="data-row"><span class="data-label">My Preparations:</span><span>${window.appData.myScans.filter(s => s.type === 'kitchen' && s.user === window.appData.user && s.dish === window.appData.dishLetter).length} bowls</span></div>
                `;
            } else {
                element.innerHTML = `
                    <div class="data-row"><span class="data-label">Today's Preparations:</span><span>${preparedToday} bowls</span></div>
                    <div class="data-row"><span class="data-label">Active Bowls:</span><span>${window.appData.activeBowls.length} bowls</span></div>
                    <div class="data-row"><span class="data-label">My Returns:</span><span>${window.appData.myScans.filter(s => s.type === 'return' && s.user === window.appData.user).length} bowls</span></div>
                `;
            }
        }

        function showMessage(text, type) {
            const element = document.getElementById('feedback');
            element.textContent = text;
            element.className = 'feedback ' + type;
        }

        // Simple Excel Export
        async function exportToExcel() {
            showMessage("üì§ Exporting to Excel...", "info");
        }

        // Dish Statistics function
        function updateDishStatistics() {
            const statsBody = document.getElementById('dishStatsBody');
            const updateTime = document.getElementById('statsUpdateTime');
            
            const dishData = {};
            const allDishes = [...'ABCDEFGHIJKLMNOPQRSTUVWXYZ1234'];
            
            allDishes.forEach(dish => {
                dishData[dish] = {
                    scanned: 0,
                    preparedBy: {},
                    firstScanTime: null,
                    lastScanTime: null
                };
            });
            
            window.appData.preparedBowls.forEach(bowl => {
                if (isToday(bowl.timestamp)) {
                    const dish = bowl.dish;
                    const user = bowl.user;
                    const scanTime = new Date(bowl.timestamp);
                    
                    if (!dishData[dish]) {
                        dishData[dish] = { scanned: 0, preparedBy: {}, firstScanTime: null, lastScanTime: null };
                    }
                    
                    dishData[dish].scanned++;
                    
                    if (!dishData[dish].preparedBy[user]) {
                        dishData[dish].preparedBy[user] = 0;
                    }
                    dishData[dish].preparedBy[user]++;
                    
                    if (!dishData[dish].firstScanTime || scanTime < new Date(dishData[dish].firstScanTime)) {
                        dishData[dish].firstScanTime = bowl.timestamp;
                    }
                    if (!dishData[dish].lastScanTime || scanTime > new Date(dishData[dish].lastScanTime)) {
                        dishData[dish].lastScanTime = bowl.timestamp;
                    }
                }
            });
            
            let totalScanned = 0;
            let totalExpected = 0;
            let html = '';
            
            allDishes.forEach(dish => {
                const data = dishData[dish] || { scanned: 0, preparedBy: {}, firstScanTime: null, lastScanTime: null };
                const scanned = data.scanned;
                const expected = window.appData.expectedCounts[dish] || 0;
                const difference = scanned - expected;
                
                totalScanned += scanned;
                totalExpected += expected;
                
                const preparers = Object.entries(data.preparedBy);
                const topPreparer = preparers.length > 0 ? 
                    preparers.sort((a, b) => b[1] - a[1])[0] : 
                    null;
                
                const firstTime = data.firstScanTime ? 
                    new Date(data.firstScanTime).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'}) : '-';
                const lastTime = data.lastScanTime ? 
                    new Date(data.lastScanTime).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'}) : '-';
                
                let status = '‚úÖ OK';
                let statusClass = '';
                
                if (expected > 0) {
                    if (difference < 0) {
                        status = `‚ùå Missing ${Math.abs(difference)}`;
                        statusClass = 'missing';
                    } else if (difference > 0) {
                        status = `‚ö†Ô∏è Extra ${difference}`;
                        statusClass = 'extra';
                    }
                } else {
                    status = scanned > 0 ? 'üìù Scanned' : '‚ûñ No orders';
                }
                
                html += `
                    <tr>
                        <td class="dish-header">${dish}</td>
                        <td class="prepared-by">${topPreparer ? `${topPreparer[0]} (${topPreparer[1]})` : '-'}</td>
                        <td>${scanned}</td>
                        <td class="${expected > 0 ? 'expected-highlight' : ''}">${expected > 0 ? expected : '-'}</td>
                        <td>${expected > 0 ? (difference >= 0 ? `+${difference}` : difference) : '-'}</td>
                        <td class="time-info">${firstTime}</td>
                        <td class="time-info">${lastTime}</td>
                        <td class="${statusClass}">${status}</td>
                    </tr>
                `;
            });
            
            const totalDifference = totalScanned - totalExpected;
            html += `
                <tr class="total-row">
                    <td><strong>TOTAL</strong></td>
                    <td><strong>-</strong></td>
                    <td><strong>${totalScanned}</strong></td>
                    <td><strong>${totalExpected}</strong></td>
                    <td><strong>${totalExpected > 0 ? (totalDifference >= 0 ? `+${totalDifference}` : totalDifference) : '-'}</strong></td>
                    <td><strong>-</strong></td>
                    <td><strong>-</strong></td>
                    <td><strong>${totalExpected > 0 ? (totalDifference === 0 ? '‚úÖ Perfect' : (totalDifference > 0 ? `‚ö†Ô∏è Extra ${totalDifference}` : `‚ùå Missing ${Math.abs(totalDifference)}`)) : 'No orders set'}</strong></td>
                </tr>
            `;
            
            statsBody.innerHTML = html;
            updateTime.textContent = new Date().toLocaleTimeString();
        }

        window.consolidateTodayData = consolidateTodayData;
        window.forceReleaseLock = forceReleaseLock;
    </script>
</body>
</html>
